---
title: "Best Practices"
description: "Optimize your API usage with caching, rate limiting, and performance tips"
---

## Overview

Follow these best practices to build efficient, reliable, and performant integrations with ApiAju.

## Caching Strategies

Holiday data doesn't change frequently, making it ideal for caching. Implement proper caching to reduce API calls and improve performance.

### Browser-Side Caching

<Tabs>
  <Tab title="LocalStorage">
    ```javascript
    class HolidayCache {
      static CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours
      
      static getCacheKey(year) {
        return `apiaju_holidays_${year}`;
      }
      
      static set(year, data) {
        const cacheData = {
          data,
          timestamp: Date.now(),
          year
        };
        
        try {
          localStorage.setItem(
            this.getCacheKey(year),
            JSON.stringify(cacheData)
          );
        } catch (error) {
          console.warn('Failed to cache data:', error);
        }
      }
      
      static get(year) {
        try {
          const cached = localStorage.getItem(this.getCacheKey(year));
          
          if (!cached) return null;
          
          const { data, timestamp } = JSON.parse(cached);
          const age = Date.now() - timestamp;
          
          // Check if cache is still valid
          if (age < this.CACHE_DURATION) {
            return data;
          }
          
          // Cache expired, remove it
          this.clear(year);
          return null;
          
        } catch (error) {
          console.warn('Failed to read cache:', error);
          return null;
        }
      }
      
      static clear(year) {
        localStorage.removeItem(this.getCacheKey(year));
      }
      
      static clearAll() {
        Object.keys(localStorage)
          .filter(key => key.startsWith('apiaju_holidays_'))
          .forEach(key => localStorage.removeItem(key));
      }
    }

    // Usage
    async function getHolidays(year) {
      // Try cache first
      const cached = HolidayCache.get(year);
      if (cached) {
        console.log('Using cached data');
        return cached;
      }
      
      // Fetch from API
      const response = await fetch(
        `https://api.aju.br/api/v1/calendar/holidays?year=${year}`
      );
      const result = await response.json();
      
      // Cache the result
      HolidayCache.set(year, result.data);
      
      return result.data;
    }
    ```
  </Tab>

  <Tab title="Memory Cache">
    ```javascript
    class MemoryCache {
      constructor(ttl = 3600000) { // 1 hour default
        this.cache = new Map();
        this.ttl = ttl;
      }
      
      set(key, value) {
        this.cache.set(key, {
          value,
          expiry: Date.now() + this.ttl
        });
      }
      
      get(key) {
        const item = this.cache.get(key);
        
        if (!item) return null;
        
        if (Date.now() > item.expiry) {
          this.cache.delete(key);
          return null;
        }
        
        return item.value;
      }
      
      has(key) {
        return this.get(key) !== null;
      }
      
      clear() {
        this.cache.clear();
      }
    }

    // Create a singleton cache instance
    const holidayCache = new MemoryCache(24 * 60 * 60 * 1000); // 24 hours

    async function getHolidaysWithCache(year) {
      const cacheKey = `holidays_${year}`;
      
      if (holidayCache.has(cacheKey)) {
        return holidayCache.get(cacheKey);
      }
      
      const response = await fetch(
        `https://api.aju.br/api/v1/calendar/holidays?year=${year}`
      );
      const data = await response.json();
      
      holidayCache.set(cacheKey, data.data);
      
      return data.data;
    }
    ```
  </Tab>

  <Tab title="IndexedDB">
    ```javascript
    class IndexedDBCache {
      constructor(dbName = 'ApiAjuCache', storeName = 'holidays') {
        this.dbName = dbName;
        this.storeName = storeName;
        this.db = null;
      }
      
      async init() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, 1);
          
          request.onerror = () => reject(request.error);
          request.onsuccess = () => {
            this.db = request.result;
            resolve();
          };
          
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(this.storeName)) {
              db.createObjectStore(this.storeName, { keyPath: 'key' });
            }
          };
        });
      }
      
      async set(key, value, ttl = 24 * 60 * 60 * 1000) {
        if (!this.db) await this.init();
        
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          
          const data = {
            key,
            value,
            expiry: Date.now() + ttl
          };
          
          const request = store.put(data);
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      }
      
      async get(key) {
        if (!this.db) await this.init();
        
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.storeName], 'readonly');
          const store = transaction.objectStore(this.storeName);
          const request = store.get(key);
          
          request.onsuccess = () => {
            const item = request.result;
            
            if (!item || Date.now() > item.expiry) {
              resolve(null);
            } else {
              resolve(item.value);
            }
          };
          
          request.onerror = () => reject(request.error);
        });
      }
    }

    // Usage
    const cache = new IndexedDBCache();

    async function getHolidaysWithIndexedDB(year) {
      const cacheKey = `holidays_${year}`;
      
      // Try cache first
      const cached = await cache.get(cacheKey);
      if (cached) return cached;
      
      // Fetch from API
      const response = await fetch(
        `https://api.aju.br/api/v1/calendar/holidays?year=${year}`
      );
      const data = await response.json();
      
      // Cache for 24 hours
      await cache.set(cacheKey, data.data);
      
      return data.data;
    }
    ```
  </Tab>
</Tabs>

### Server-Side Caching

<CodeGroup>

```javascript Node.js + Redis
const redis = require('redis');
const client = redis.createClient();

client.on('error', (err) => console.error('Redis error:', err));

async function getHolidaysWithRedis(year) {
  const cacheKey = `apiaju:holidays:${year}`;
  
  try {
    // Check cache
    const cached = await client.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // Fetch from API
    const response = await fetch(
      `https://api.aju.br/api/v1/calendar/holidays?year=${year}`
    );
    const data = await response.json();
    
    // Cache for 24 hours
    await client.setEx(cacheKey, 86400, JSON.stringify(data.data));
    
    return data.data;
  } catch (error) {
    console.error('Cache error:', error);
    throw error;
  }
}
```

```python Python + Flask-Caching
from flask import Flask
from flask_caching import Cache
import requests

app = Flask(__name__)
cache = Cache(app, config={
    'CACHE_TYPE': 'redis',
    'CACHE_REDIS_URL': 'redis://localhost:6379/0',
    'CACHE_DEFAULT_TIMEOUT': 86400  # 24 hours
})

@cache.memoize(timeout=86400)
def get_holidays(year):
    """Fetch holidays with automatic caching"""
    response = requests.get(
        f'https://api.aju.br/api/v1/calendar/holidays?year={year}'
    )
    response.raise_for_status()
    return response.json()['data']

@app.route('/holidays/<int:year>')
def holidays_endpoint(year):
    try:
        holidays = get_holidays(year)
        return {'holidays': holidays}
    except requests.RequestException as e:
        return {'error': str(e)}, 500
```

```typescript Next.js (App Router)
// app/api/holidays/[year]/route.ts
import { NextResponse } from 'next/server';

export const revalidate = 86400; // Revalidate every 24 hours

export async function GET(
  request: Request,
  { params }: { params: { year: string } }
) {
  try {
    const response = await fetch(
      `https://api.aju.br/api/v1/calendar/holidays?year=${params.year}`,
      {
        next: {
          revalidate: 86400, // Cache for 24 hours
          tags: [`holidays-${params.year}`]
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch holidays');
    }

    const data = await response.json();
    
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch holidays' },
      { status: 500 }
    );
  }
}
```

</CodeGroup>

## Rate Limiting

While ApiAju doesn't enforce strict rate limits, it's important to use the API responsibly.

### Best Practices for Rate Limiting

<AccordionGroup>
  <Accordion title="Implement Client-Side Rate Limiting" icon="gauge">
    Prevent accidental abuse by implementing rate limiting in your application:

    ```javascript
    class RateLimiter {
      constructor(maxRequests, timeWindow) {
        this.maxRequests = maxRequests;
        this.timeWindow = timeWindow;
        this.requests = [];
      }
      
      canMakeRequest() {
        const now = Date.now();
        
        // Remove old requests outside the time window
        this.requests = this.requests.filter(
          time => now - time < this.timeWindow
        );
        
        return this.requests.length < this.maxRequests;
      }
      
      recordRequest() {
        this.requests.push(Date.now());
      }
      
      async waitIfNeeded() {
        if (!this.canMakeRequest()) {
          const oldestRequest = this.requests[0];
          const waitTime = this.timeWindow - (Date.now() - oldestRequest);
          
          await new Promise(resolve => setTimeout(resolve, waitTime));
        }
      }
    }

    // Limit to 100 requests per minute
    const limiter = new RateLimiter(100, 60000);

    async function makeApiCall(url) {
      await limiter.waitIfNeeded();
      limiter.recordRequest();
      
      return fetch(url);
    }
    ```
  </Accordion>

  <Accordion title="Batch Requests Efficiently" icon="layer-group">
    When fetching data for multiple years, use concurrent requests but limit concurrency:

    ```javascript
    async function fetchMultipleYears(years, concurrency = 3) {
      const results = [];
      
      for (let i = 0; i < years.length; i += concurrency) {
        const batch = years.slice(i, i + concurrency);
        
        const promises = batch.map(year =>
          fetch(`https://api.aju.br/api/v1/calendar/holidays?year=${year}`)
            .then(r => r.json())
        );
        
        const batchResults = await Promise.all(promises);
        results.push(...batchResults);
        
        // Small delay between batches
        if (i + concurrency < years.length) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      
      return results;
    }

    // Usage
    const years = [2024, 2025, 2026, 2027, 2028];
    const allHolidays = await fetchMultipleYears(years);
    ```
  </Accordion>

  <Accordion title="Avoid Unnecessary Requests" icon="ban">
    Don't make redundant API calls:

    ```javascript
    // ❌ Bad: Multiple unnecessary calls
    async function badExample() {
      const holidays2024 = await fetchHolidays(2024);
      const holidays2024Again = await fetchHolidays(2024); // Duplicate!
      const holidays2024AgainAgain = await fetchHolidays(2024); // Duplicate!
    }

    // ✅ Good: Use caching and request deduplication
    const pendingRequests = new Map();

    async function fetchHolidays(year) {
      const cacheKey = `holidays_${year}`;
      
      // Check if request is already in flight
      if (pendingRequests.has(cacheKey)) {
        return pendingRequests.get(cacheKey);
      }
      
      // Create new request
      const promise = (async () => {
        const response = await fetch(
          `https://api.aju.br/api/v1/calendar/holidays?year=${year}`
        );
        return response.json();
      })();
      
      pendingRequests.set(cacheKey, promise);
      
      try {
        const result = await promise;
        return result;
      } finally {
        pendingRequests.delete(cacheKey);
      }
    }

    // Now these will only make one actual API call
    async function goodExample() {
      const [holidays1, holidays2, holidays3] = await Promise.all([
        fetchHolidays(2024),
        fetchHolidays(2024),
        fetchHolidays(2024)
      ]);
    }
    ```
  </Accordion>
</AccordionGroup>

## Performance Optimization

### 1. Prefetch Data

Prefetch data that you know you'll need:

```javascript
// Prefetch holidays when the app loads
async function initializeApp() {
  const currentYear = new Date().getFullYear();
  const nextYear = currentYear + 1;
  
  // Prefetch current and next year in parallel
  Promise.all([
    fetchHolidays(currentYear),
    fetchHolidays(nextYear)
  ]).catch(error => {
    console.warn('Failed to prefetch holidays:', error);
  });
  
  // Continue with app initialization
}
```

### 2. Use Appropriate Data Structures

Store and access holiday data efficiently:

```javascript
class HolidayManager {
  constructor(holidays) {
    // Create a Map for O(1) lookup by date
    this.holidayMap = new Map(
      holidays.map(h => [h.date, h])
    );
    
    // Keep original array for iteration
    this.holidays = holidays;
  }
  
  isHoliday(date) {
    return this.holidayMap.has(date);
  }
  
  getHoliday(date) {
    return this.holidayMap.get(date);
  }
  
  getHolidaysByType(type) {
    return this.holidays.filter(h => h.type === type);
  }
  
  getNationalHolidays() {
    return this.getHolidaysByType('national');
  }
  
  getStateHolidays() {
    return this.getHolidaysByType('state');
  }
  
  getMunicipalHolidays() {
    return this.getHolidaysByType('municipal');
  }
}

// Usage
const response = await fetch('https://api.aju.br/api/v1/calendar/holidays?year=2024');
const data = await response.json();

const manager = new HolidayManager(data.data);

// Fast lookup
console.log(manager.isHoliday('2024-12-25')); // true
console.log(manager.getHoliday('2024-12-25')); // { date, name, type }
```

### 3. Minimize Payload Size

Request only what you need:

```javascript
// If you only need to check if a specific date is a holiday,
// use the is-holiday endpoint instead of fetching all holidays
const isHoliday = await fetch(
  'https://api.aju.br/api/v1/calendar/holidays/is-holiday?date=2024-12-25'
).then(r => r.json());

// Instead of:
// const allHolidays = await fetch('https://api.aju.br/api/v1/calendar/holidays?year=2024')
//   .then(r => r.json());
// const isHoliday = allHolidays.data.some(h => h.date === '2024-12-25');
```

### 4. Implement Progressive Loading

Load data progressively for better UX:

```javascript
async function loadHolidaysProgressively(year) {
  // Show loading state immediately
  showLoadingState();
  
  try {
    // Start the request
    const response = await fetch(
      `https://api.aju.br/api/v1/calendar/holidays?year=${year}`
    );
    const data = await response.json();
    
    // Process data in chunks for smooth UI
    const holidays = data.data;
    const chunkSize = 10;
    
    for (let i = 0; i < holidays.length; i += chunkSize) {
      const chunk = holidays.slice(i, i + chunkSize);
      displayHolidays(chunk);
      
      // Let UI breathe between chunks
      await new Promise(resolve => setTimeout(resolve, 0));
    }
    
    hideLoadingState();
  } catch (error) {
    showError(error);
  }
}
```

## Security Best Practices

<AccordionGroup>
  <Accordion title="Sanitize User Input" icon="shield-check">
    Always validate and sanitize user inputs before making API calls:

    ```javascript
    function sanitizeYear(input) {
      // Convert to number and validate
      const year = Number(input);
      
      if (!Number.isInteger(year) || year < 1900 || year > 2199) {
        throw new Error('Invalid year');
      }
      
      return year;
    }

    function sanitizeDate(input) {
      // Validate date format and value
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
      
      if (!dateRegex.test(input)) {
        throw new Error('Invalid date format');
      }
      
      const date = new Date(input);
      if (isNaN(date.getTime())) {
        throw new Error('Invalid date');
      }
      
      return input;
    }
    ```
  </Accordion>

  <Accordion title="Use HTTPS" icon="lock">
    Always use HTTPS for API calls (which ApiAju already uses):

    ```javascript
    // ✅ Good
    const url = 'https://api.aju.br/api/v1/calendar/holidays';

    // ❌ Never use HTTP
    // const url = 'http://api.aju.br/api/v1/calendar/holidays';
    ```
  </Accordion>

  <Accordion title="Don't Expose Sensitive Data" icon="eye-slash">
    If you're building a proxy API, don't expose internal details:

    ```javascript
    // ❌ Bad: Exposes internal details
    app.get('/api/holidays/:year', async (req, res) => {
      try {
        const response = await fetch(`https://api.aju.br/api/v1/calendar/holidays?year=${req.params.year}`);
        res.json(await response.json());
      } catch (error) {
        res.status(500).json({ error: error.stack }); // Exposes stack trace!
      }
    });

    // ✅ Good: Returns clean error messages
    app.get('/api/holidays/:year', async (req, res) => {
      try {
        const year = sanitizeYear(req.params.year);
        const response = await fetch(`https://api.aju.br/api/v1/calendar/holidays?year=${year}`);
        
        if (!response.ok) {
          return res.status(response.status).json({
            error: 'Failed to fetch holidays'
          });
        }
        
        res.json(await response.json());
      } catch (error) {
        res.status(400).json({ error: 'Invalid request' });
      }
    });
    ```
  </Accordion>
</AccordionGroup>

## Monitoring and Logging

Track API usage and errors for better insights:

```javascript
class ApiMonitor {
  constructor() {
    this.stats = {
      requests: 0,
      errors: 0,
      cacheHits: 0,
      cacheMisses: 0,
      totalResponseTime: 0
    };
  }
  
  async monitoredFetch(url, options = {}) {
    const startTime = performance.now();
    this.stats.requests++;
    
    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        this.stats.errors++;
        this.logError(url, response.status);
      }
      
      return response;
    } catch (error) {
      this.stats.errors++;
      this.logError(url, error);
      throw error;
    } finally {
      const endTime = performance.now();
      this.stats.totalResponseTime += (endTime - startTime);
    }
  }
  
  recordCacheHit() {
    this.stats.cacheHits++;
  }
  
  recordCacheMiss() {
    this.stats.cacheMisses++;
  }
  
  getStats() {
    return {
      ...this.stats,
      avgResponseTime: this.stats.requests > 0
        ? this.stats.totalResponseTime / this.stats.requests
        : 0,
      errorRate: this.stats.requests > 0
        ? (this.stats.errors / this.stats.requests) * 100
        : 0,
      cacheHitRate: (this.stats.cacheHits + this.stats.cacheMisses) > 0
        ? (this.stats.cacheHits / (this.stats.cacheHits + this.stats.cacheMisses)) * 100
        : 0
    };
  }
  
  logError(url, error) {
    console.error(`API Error: ${url}`, error);
    
    // Send to your monitoring service
    // sendToMonitoring({ url, error, timestamp: Date.now() });
  }
}

// Usage
const monitor = new ApiMonitor();

async function fetchHolidays(year) {
  const response = await monitor.monitoredFetch(
    `https://api.aju.br/api/v1/calendar/holidays?year=${year}`
  );
  return response.json();
}

// Check stats
console.log(monitor.getStats());
```

## Checklist

Use this checklist when integrating ApiAju:

<Steps>
  <Step title="Implementation">
    - [ ] Implement proper error handling
    - [ ] Add input validation
    - [ ] Set up caching strategy
    - [ ] Add rate limiting (if applicable)
    - [ ] Use HTTPS for all requests
  </Step>
  
  <Step title="Performance">
    - [ ] Cache holiday data appropriately
    - [ ] Minimize unnecessary API calls
    - [ ] Use efficient data structures
    - [ ] Implement request deduplication
  </Step>
  
  <Step title="User Experience">
    - [ ] Show loading states
    - [ ] Display user-friendly error messages
    - [ ] Handle offline scenarios
    - [ ] Implement retry logic for failures
  </Step>
  
  <Step title="Monitoring">
    - [ ] Log API errors
    - [ ] Track API usage
    - [ ] Monitor response times
    - [ ] Set up alerts for failures
  </Step>
</Steps>

## Additional Resources

<CardGroup cols={2}>
  <Card
    title="API Reference"
    icon="book"
    href="/api-reference/introduction"
  >
    Complete endpoint documentation
  </Card>
  <Card
    title="Use Cases"
    icon="lightbulb"
    href="/use-cases"
  >
    Real-world integration examples
  </Card>
  <Card
    title="Error Handling"
    icon="shield-halved"
    href="/error-handling"
  >
    Comprehensive error handling guide
  </Card>
  <Card
    title="GitHub"
    icon="github"
    href="https://github.com/wolney-fo/apiaju"
  >
    Contribute or report issues
  </Card>
</CardGroup>

